use std::str::FromStr;
use crate::ast::*;

grammar;



pub Expr: Box<Expr> = {
    Expr ExprOp Factor => Box::new(Expr::Op(<>)),
    Factor,
}

ExprOp: Op = { 
    "+" => Op::Add,
    "-" => Op::Sub,
}

Factor: Box<Expr> = {
    Factor FactorOp Term => Box::new(Expr::Op(<>)),
    Term,
}

FactorOp: Op = {
    "*" => Op::Mul,
    "/" => Op::Div,
}

Term: Box<Expr> = {
    Num => Box::new(Expr::Number(<>)),
    "(" <Expr> ")"
}

Num: i32 = {
    <n:r"[-]?[0-9]+"> => i32::from_str(n).unwrap(),
}

pub FunctionDec: Box<FunctionDec> = {
    "fn" <name:String> "(" <params:Comma<Params>> ")" "->" <return_type:String> "{" <body:Statement> "}" => Box::new(FunctionDec{name, params, return_type, body}),

}

Params: Params = {
    <name:String> ":" <data_type:String> => Params{<>}
}

pub Statement: Box<Statement> = {
    "let" <name:String> ":" <data_type:String> "=" <expr:Expr> ";" => Box::new(Statement::Let(<>)),
    "if" <cond:Expr> "{" <body:String> "}" => Box::new(Statement::If(<>)),
    "else" "{" <body:Expr> "}" => Box::new(Statement::Else(<>)),
    "return" <expr:Expr> ";" => Box::new(Statement::Return(<>)),

    
}


String: String = {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string()
}

Comma<T>:Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}


//match {
//    r"[-]?[0-9]+"
//} else {
//    r"(?i)fn\s" => FUNCTION,
//    r"[\w_][\w_\d]*" => IDENTIFIER,
//    _
//}