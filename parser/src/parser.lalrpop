use std::str::FromStr;
use crate::ast::*;

grammar;

pub Program = <FunctionDec*>;

pub Expr: Box<Expr> = {
    Cond,
    Expr ExprBinOp Factor => Box::new(Expr::Op(<>)),
    Factor,
}

ExprBinOp: Op = { 
    "+" => Op::Add,
    "-" => Op::Sub,
}

Factor: Box<Expr> = {
    Factor FactorBinOp Term => Box::new(Expr::Op(<>)),
    Term,
}

FactorBinOp: Op = {
    "*" => Op::Mul,
    "/" => Op::Div,
}

Term: Box<Expr> = {
    Num => Box::new(Expr::Number(<>)),
    Id => Box::new(Expr::Var(<>)),
    "(" <Expr> ")"
}

Num: i32 = {
    <n:r"[-]?[0-9]+"> => i32::from_str(n).unwrap(),
}

FunctionDec: Box<FunctionDec> = {
    "fn" <name:Id> "(" <params:Comma<Params>> ")" "->" <return_type:Type> "{" <body:Statement*> "}" => Box::new(FunctionDec{name, params, return_type, body}),

}

Params: Params = {
    <name:Id> ":" <data_type:Type> => Params{<>}
}

Statement: Box<Statement> = {
    "let" <name:Id> ":" <data_type:Type> <op:Assign> <expr:Expr> ";" => Box::new(Statement::Let(<>)),
    "if" <cond:Expr> "{" <body:Statement*> "}" => Box::new(Statement::If(<>)),
    "else" "{" <body:Statement*> "}" => Box::new(Statement::Else(<>)),
    "while" <cond:Expr> "{" <body:Statement*> "}" => Box::new(Statement::While(<>)),
    "return" <expr:Expr> ";" => Box::new(Statement::Return(expr)),

}
Cond: Box<Expr> = {
    Expr CondOp Expr => Box::new(Expr, Expr::Op(<>))

}

CondOp: Op = {
    ">" => Op::GreaterThan,
    "<" => Op::LessThan,
}

Assign: Op = {
    "=" => Op::Equal,
    "+=" => Op::AddEq,
    "-=" => Op::SubEq,
    "/=" => Op::DivEq,
    "*=" => Op::MulEq,
}

Type: Type = {
    "i32" => Type::I32,
    "bool" => Type::Bool,
}

Id: String = {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string()
}

Comma<T>:Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}


//match {
//    r"[-]?[0-9]+"
//} else {
//    r"(?i)fn\s" => FUNCTION,
//    r"[\w_][\w_\d]*" => IDENTIFIER,
//    _
//}